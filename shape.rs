use arrayvec::ArrayVec;
use flo_curves::bezier::curve_intersects_ray;
use flo_curves::{BezierCurve, BoundingBox, Coord2 as FloCoord};
use super::{value_no_nans, Length, Point, Range, Region, Size, Vec2};

/// An axis-aligned rectangle defined by a minimum and maximum point.
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct Rect {
    /// The minimum (bottom-left) point.
    pub min: Point,
    /// The maximum (top-right) point.
    pub max: Point,
}

impl Rect {
    /// Create a rectangle from minimum and maximum point.
    pub fn new(min: Point, max: Point) -> Rect {
        Rect { min, max }
    }

    /// The size (width / height) of this rectangle.
    pub fn size(self) -> Size {
        Size::new(self.max.x - self.min.x, self.max.y - self.min.y)
    }

    /// The tightest rectangle that contains this and another rectangle.
    pub fn union(self, other: Rect) -> Rect {
        Rect {
            min: self.min.min(other.min),
            max: self.max.max(other.max),
        }
    }
}

impl_approx_eq!(Rect [min, max]);

/// A closed shape defined by a list of connected cubic bezier curves.
#[derive(Debug, Clone, PartialEq)]
pub struct Shape {
    /// The list of start-, control- and endpoints as explained in `Shape::new`.
    points: Vec<Point>,
    /// The bounding boxes of the individual bezier curves.
    bboxes: Vec<Rect>,
    /// The bounding box of the whole shape.
    bounds: Rect,
}

/// A cubic bezier curve.
///
/// Such a curve consists of a start point, two control points and an end point.
#[derive(Debug, Copy, Clone, PartialEq)]
struct Curve {
    start: Point,
    c1: Point,
    c2: Point,
    end: Point,
}

impl Shape {
    /// Create a new shape from a list of points in the format
    /// `[s1, c1, c1, e1, c2, c2, e2, ...]` where:
    /// - `s_n` is the starting point of the n-th cubic bezier,
    /// - `c_n` are the control points of the n-th curve,
    /// - `e_n` (or equivalently `s_(n+1)`) is the shared end point of the n-th
    ///   and start point of the (n+1)-th curve.
    ///
    /// The shape is always closed and as such the last curve is defined by the
    /// last three and the first point in the listing.
    ///
    /// A further consequence of the closedness is that every valid shape
    /// definition consists of at least 9 points and the number of points is
    /// always divisible by three.
    pub fn new(points: Vec<Point>) -> Shape {
        assert!(
            points.len() >= 9 && points.len() % 3 == 0,
            "invalid shape definition"
        );

        let mut bboxes = vec![];
        let mut bounds = Rect::new(points[0], points[0]);

        for curve in curves(&points) {
            let bbox = rect(flo_curve(curve).bounding_box::<FloBounds>());
            bounds = bounds.union(bbox);
            bboxes.push(bbox);
        }

        Shape {
            points,
            bboxes,
            bounds,
        }
    }

    /// The axis-aligned bounding box of the full shape.
    pub fn bounds(&self) -> Rect {
        self.bounds
    }

    /// Returns all horizontal ranges in the given vertical range that do not
    /// collide with the shape and are either fully inside or outside of the
    /// shape depending on the second argument.
    ///
    /// For intuition about this, have a look at `out/ranges.png` which is
    /// generated by the tests of this function.
    pub fn segments(&self, v_range: Range, inside: bool) -> Vec<Range> {
        const EPS: Length = Length::pt(1e-4);

        // Shrink the range a little to categorize correctly when the bounding
        // box of the shape is used directly to select the `v_range`. But make
        // sure that the end does not lie before the start.
        let mut v_range = v_range.shrunk(EPS, EPS);
        v_range.end.make_max(v_range.start);

        let Range { start, end } = v_range;
        let width = self.bounds.max.x - self.bounds.min.x;
        let top = (flo_coord(Point::with_y(start)), flo_coord(Point::new(width, start)));
        let bot = (flo_coord(Point::with_y(end)), flo_coord(Point::new(width, end)));

        // The ranges inside the range that are occupied by the shape.
        let mut occupied = vec![];

        // The points where the curve crosses the top end of the range and the
        // last region the curve was in to find these crossings.
        let mut crossings = vec![];
        let mut last_region = None;

        // Determine the segments.
        for (curve, bounds) in self.curves() {
            let min_region = v_range.region(bounds.min.y);
            let max_region = v_range.region(bounds.max.y);

            // If the curve does not even hit the rays, we can skip ahead.
            if min_region == max_region {
                if min_region == Region::Inside {
                    let range = Range::new(bounds.min.x, bounds.max.x);
                    occupied.push(range);
                }

                last_region = Some(min_region);
                continue;
            }

            // Find all intersection points with a ray.
            let flo = flo_curve(curve);
            let search = |ray| {
                curve_intersects_ray(&flo, ray)
                    .into_iter()
                    .map(|(t, _, hit)| (t, point(hit)))
            };

            // Determine the interesting points that span the line segments.
            let mut points: ArrayVec<[_; 8]> = ArrayVec::new();
            points.push((0.0, curve.start));
            points.extend(search(&top));
            points.extend(search(&bot));
            points.push((1.0, curve.end));

            // Sort the points by occurence on the curve because we want our
            // segments to be in the order they are on the curve.
            points.sort_by(|a, b| value_no_nans(&a.0, &b.0));

            // Turn the interesting points into segments with corresponding
            // region determined by the vertical midpoint of the segment.
            for window in points.windows(2) {
                let (from, fp) = window[0];
                let (to, tp) = window[1];
                let region = v_range.region((fp.y + tp.y) / 2.0);

                // If we change from before to inside or inverse, we cross the
                // top line and that means we encountered a point of interest
                // that we will use later to identify which ranges are inside
                // and which are outside of the shape.
                if let Some(last) = last_region {
                    if last == Region::Before && region != Region::Before ||
                       last != Region::Before && region == Region::Before {
                        crossings.push(fp.x);
                    }
                }

                last_region = Some(region);

                // Add a new occupied range if we are inside the shape.
                if region == Region::Inside {
                    occupied.push(if from < 0.0001 && to > 0.9999 {
                        Range::new(bounds.min.x, bounds.max.x)
                    } else if (to - from).abs() > 0.0001 {
                        // Don't consider to small windows because they may lead
                        // to NaNs in computation of the section.
                        let bbox = rect(flo.section(from, to).bounding_box());
                        Range::new(bbox.min.x, bbox.max.x)
                    } else {
                        Range::new(fp.x.min(tp.x), fp.x.max(tp.x))
                    });
                }
            }
        }

        // We want the unoccupied ranges, so we inverse the thing.
        let mut free = Range::inverse(&Range::simplify(occupied));
        crossings.sort_by(value_no_nans);

        // Now we decide which ranges are inside and outside of the shape by
        // looking how often a ray would cross the top end of the range before
        // it reaches the mid point of the range.
        free.retain(|range| {
            if range.is_finite() {
                let mid = range.mid();
                match crossings.binary_search_by(|c| value_no_nans(c, &mid)) {
                    Ok(_) => false,
                    Err(index) => (index % 2 == 1) == inside,
                }
            } else {
                !inside
            }
        });

        free
    }

    /// Translate the whole shape by the `offset`.
    pub fn translate(&mut self, offset: Vec2) {
        self.bounds.min += offset;
        self.bounds.max += offset;

        for bound in &mut self.bboxes {
            bound.min += offset;
            bound.max += offset;
        }

        for point in &mut self.points {
            *point += offset;
        }
    }

    /// Iterator over the bezier curves defined by the point listing and their
    /// bounding boxes.
    fn curves<'a>(&'a self) -> impl Iterator<Item = (Curve, Rect)> + 'a {
        curves(&self.points).zip(self.bboxes.iter().copied())
    }
}

impl_approx_eq!(Shape [points, bboxes]);

/// Iterator over the curves defined by a point list as defined in `Shape::new`.
fn curves<'a>(points: &'a [Point]) -> impl Iterator<Item = Curve> + 'a {
    let mut i = 0;
    std::iter::from_fn(move || {
        if i >= points.len() {
            None
        } else {
            i += 3;
            Some(Curve {
                start: points[i - 3],
                c1: points[i - 2],
                c2: points[i - 1],
                end: points[i % points.len()],
            })
        }
    })
}

type FloCurve = flo_curves::bezier::Curve<FloCoord>;
type FloBounds = flo_curves::Bounds<FloCoord>;

/// Transform a curve struct into a flo curve.
fn flo_curve(curve: Curve) -> FloCurve {
    FloCurve {
        start_point: flo_coord(curve.start),
        control_points: (flo_coord(curve.c1), flo_coord(curve.c2)),
        end_point: flo_coord(curve.end),
    }
}

/// Transform a point into flo coordinate.
fn flo_coord(point: Point) -> FloCoord {
    FloCoord(point.x.to_pt() as f64, point.y.to_pt() as f64)
}

/// Transform a flo coordinate into a point.
fn point(coord: FloCoord) -> Point {
    Point::new(Length::pt(coord.0 as f32), Length::pt(coord.1 as f32))
}

/// Transform flo bounds into a rect.
fn rect(bounds: FloBounds) -> Rect {
    Rect::new(point(bounds.min()), point(bounds.max()))
}
